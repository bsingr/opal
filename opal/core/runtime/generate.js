/* 
 * generate.js
 * vienna
 * 
 * Created by Adam Beynon.
 * Copyright 2010 Adam Beynon.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 ISeq types
*/
var ISEQ_TYPE_TOP = 1,
   ISEQ_TYPE_METHOD = 2,
   ISEQ_TYPE_BLOCK = 3,
   ISEQ_TYPE_CLASS = 4,
   ISEQ_TYPE_RESCUE = 5,
   ISEQ_TYPE_ENSURE = 6,
   ISEQ_TYPE_EVAL = 7,
   ISEQ_TYPE_MAIN = 8;
   
   /**
     ISEQ
   */
   function Iseq(type) {
     this.type = type;
     this.locals = {};
     this.args = {};
     this.norm_arg_names = [];
     this.opt_arg_names = [];
     this.rest_arg_names = [];
     this.post_arg_names = [];
     this.block_arg_name = nil;
     // dont really need to use this for client side eval
     this.local_current = "a";
     this.code = [];
     this.method_id = null;

     return this;
   };

   Iseq.prototype = {

     push_local_name: function(name) {
       var id = this.local_current;
       this.local_current = String.fromCharCode(this.local_current.charCodeAt(0) + 1);
       this.locals[name] = "_" + id;
       return "_" + id;
     },

     lookup_local: function(name) {
       if (name === null || name === undefined) return null;
       if (this.locals[name]) return this.locals[name];
       if (this.args[name]) return this.args[name];
       if (this.block_arg_name === name) return "_";
       return null;
     },

     set_method_id: function(method_id) {
       this.method_id = method_id;
     },

     push_arg_name: function(arg_name) {
       var id = this.local_current;
       this.local_current = String.fromCharCode(this.local_current.charCodeAt(0) + 1);
       this.args[arg_name] = "_" + id;
       this.norm_arg_names.push(arg_name);
       return "_" + id;
     },

     set_parent_iseq: function(parent_iseq) {

     },

     finalize: function() {

     },

     write: function(str) {
       this.code.push(str);
     },

     toString: function() {
       var r = [];
       switch (this.type) {
         case ISEQ_TYPE_TOP:
          r.push("function($){");
          r.push("var _ = nil;");
          if (this.locals.length > 0) {
            r.push("var ");
            for (var i = 0; i < this.locals.length; i++) {
              if (i != 0) r.push(",");
              r.push(this.locals[i]);
            }
            r.push(";");
          }
          r.push(this.code.join(""));
          r.push("}");
          break;
        case ISEQ_TYPE_CLASS:
          r.push("function($){");
          r.push(this.code.join(""));
          r.push("}");
          break;
        case ISEQ_TYPE_METHOD:
          this.deal_with_method_args(r);
          r.push(this.code.join(""));
          r.push("}");
          break;
       case ISEQ_TYPE_BLOCK:
         r.push("function($$,__,ID");
         for (var i = 0; i < this.norm_arg_names.length; i++) {
           r.push(",");
           r.push(this.args[this.norm_arg_names[i]]);
         }
         r.push("){")
         r.push("with({$:($$==nil?$:$$),_:(__==nil?_:__)}){");
         r.push(this.code.join(""));
         r.push("}");
         r.push("}");
          break;
        default:
          throw "unknown iseq type in parse.js"
          }
       return r.join("");
     },

     deal_with_method_args: function(r) {
       r.push("function($,id,_");
       r.push("){");
     }
   };


/**
  Used for generating ruby code from the node tree generated by the parser
*/ 
var OpalRubyGenerator = function OpalRubyGenerator(rubyParser, nodeTree) {
  
  var iseq_current = null;
  var iseq_stack = [];
  
  function iseq_stack_push(type) {
    iseq_current = new Iseq(type);
    iseq_stack.push(iseq_current);
    return iseq_current;
  };
  
  function iseq_stack_pop() {
    var iseq = iseq_current;
    iseq_stack.pop();
    iseq_current = iseq_stack[iseq_stack.length - 1];
    iseq.finalize();
    return iseq.toString();
  };
  
  function write(opcode) {
    iseq_current.write(opcode);
  };
  
  function write_label(label) {
    iseq_current.write_label(label);
  };
  
  function generate_tree(tree) {
    var top_iseq = iseq_stack_push(ISEQ_TYPE_TOP);
    for (var i = 0; i < tree.length; i++) {
      generate_stmt(tree[i], {full_stmt:true, last_stmt:false});
    }
    return iseq_stack_pop();
  };
  
  function generate_stmt(stmt, context) {
    switch (stmt.type) {
      case 'class':
        generate_class(stmt, context);
        break;
      default:
        console.log("unknown generate_stmt type: " + stmt.type + ", " + stmt.value);
    }
  };
    
  function generate_class(cls, context) {
    if (context.last_stmt && context.full_stmt) write("return ");
    
    var current_iseq = iseq_current;
    var class_iseq = iseq_stack_push(ISEQ_TYPE_CLASS);
    class_iseq.set_parent_iseq(current_iseq);
    
    // do each bodystmt
    if (cls.$stmts) {
      for (var i = 0; i < cls.$stmts.length; i++) {
        generate_stmt(cls.$stmts[i], {full_stmt: true, last_stmt:(i === cls.$stmts.length - 1)});
      }
    }
    else {
      // no statements? fake by returning nil
      write("return nil;");
    }
    
    iseq_stack_pop();
    
    write("vm_defineclass($,");
    
    // superclass
    write("nil");
    console.log(cls);
    write(",'" + cls.cpath + "'," + class_iseq.toString() + ",0)");
    
    
    if (context.full_stmt) write(";");
  };
  
  return generate_tree(nodeTree);
};
